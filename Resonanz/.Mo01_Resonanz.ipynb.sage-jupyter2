{"args":["--to","cocalc-pdf"],"start":1700989472362,"state":"done","time":1700989488478,"type":"nbconvert"}
{"backend_state":"init","connection_file":"/projects/eb6e81da-7863-4e97-93a4-17a5f721b0e7/.local/share/jupyter/runtime/kernel-230e0758-697c-490f-a8d5-ea8e8ddc470a.json","kernel":"python3-ubuntu","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.12"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1700955278541,"exec_count":4,"id":"399aa7","input":"import numpy as np\nimport PhyPraKit as ppk\nimport kafe2\nimport matplotlib.pyplot as plt\nimport scipy as sc","kernel":"python3-ubuntu","pos":3,"start":1700955276699,"state":"done","type":"cell"}
{"cell_type":"code","end":1700955315062,"exec_count":7,"id":"760b44","input":"phi_l = [0.31,0.63,1.29]\nphi_r = [0.32,0.65,1.29]\nmasses = [0.005, 0.01, 0.02]\na = [phi[i] / masses[i] for i in range(len(masses))]\nr_g = 0.0947\ng = 9.81\n\ndef theta_model(mass, theta, omega0, c=0):\n    return r_g * g * mass / (w0**2 * theta) + c\n\n#auslenkung nach links\nfit = kafe2.XYFit(xy_data=[masses, phi_l], model_function=theta_model) \nfit.add_error(axis='y', err_val=phi_error)\nfit.add_error(axis='x', err_val=0)\n\nfit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n\nfit.do_fit()\ntheta_1 = fit.parameter_values[0]\nd_theta_1 = fit.parameter_errors[0]\nplot = kafe2.Plot(fit)\nplot.x_label=\"m in kg\"\nplot.y_label=\"Phi in rad\"\nplot.customize('data', 'label', [(0, \"Linke Auslenkung\")])\nplot.plot()\nplot.show()\n\n\n#Auslenkung nach rechts\nfit = kafe2.XYFit(xy_data=[masses, phi_r], model_function=theta_model) \nfit.add_error(axis='y', err_val=phi_error)\nfit.add_error(axis='x', err_val=0)\n\nfit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n\nfit.do_fit()\ntheta_2 = fit.parameter_values[0]\nd_theta_2 = fit.parameter_errors[0]\nplot = kafe2.Plot(fit)\nplot.x_label=\"m in kg\"\nplot.y_label=\"Phi in rad\"\nplot.customize('data', 'label', [(0, \"Rechte Auslenkung\")])\nplot.plot()\nplot.show()\n\ntheta = (d_theta_1 * theta_1 + d_theta_2 * theta_2) / (d_theta_1 + d_theta_2)\nd_theta = np.sqrt(d_theta_1**2 + d_theta_2**2)\nprint(\"Gewichtete gemittelte Werte für das Trägheitsmoment Theta: ({Theta} +- {D_theta}) * kg m^2\".format(Theta = round(theta, 4), D_theta = round(d_theta, 6)))","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"d683f32b5f94be013cfbfe7d87cab453121fcd79","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"1":{"data":{"image/png":"7ec78fa7c85bef8abe4c9189bab485826ea66866","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"2":{"name":"stdout","text":"Gewichtete gemittelte Werte für das Trägheitsmoment Theta: (0.0013 +- 2.7e-05) * kg m^2\n"}},"pos":11,"start":1700955313517,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956148146,"exec_count":38,"id":"5d35fe","input":"import pandas as pd\ndf = pd.read_table(\"1.1.csv\", delimiter=\";\", decimal=\",\", usecols=(0,1,2,3,4,5,6))\nt = df[\"Zeit t / s\"].to_numpy()\nf = df[\"Frequenz f / Hz\"].to_numpy()\nphi = df[\"Weg &b_A1 / rad\"].to_numpy()\nomega = df[\"zeiliche Ableitung w_1 / rad/s\"].to_numpy()\nfft = df[\"FFT f_3 / rad\"].to_numpy()\nt_max = 1000\n\nplt.plot(t[:t_max], phi[:t_max])\nplt.title(\"Zeitlicher Verlauf des Phasenwinkels\")\nplt.xlabel(\"t in s\")\nplt.ylabel(\"Phi in rad\")\nplt.show()\nplt.plot(t[:t_max], omega[:t_max])\nplt.title(\"Zeitlicher Verlauf der Winkelgeschwindigkeit\")\nplt.xlabel(\"t in s\")\nplt.ylabel(\"Omega in rad/s\")\nplt.show()\n\nplt.plot(phi[:t_max], omega[:t_max])\nplt.title(\"Phasenraumpotrait von Phi und Omega\")\nplt.xlabel(\"Phi in rad\")\nplt.ylabel(\"Omega in rad/s\")\nplt.show()\n\npeaks, prop = sc.signal.find_peaks(fft, height=0.2)\nw0 = np.pi * 2 * f[peaks[0]]\n\na, b, c, d = sc.signal.peak_widths(fft, peaks, rel_height=0.5, prominence_data=None, wlen=None)\n\nplt.plot(f[peaks], fft[peaks], \"x\", label = \"Peak\")\nplt.hlines(y=fft[peaks[0]]/2, xmin=f[int(np.floor(c[0]))], xmax=f[int(np.ceil(d[0]))], label=\"fwhm des Peaks\")\nd_w0 = np.pi * 2 * (f[int(np.ceil(d[0]))] - f[int(np.floor(c[0]))]) \nplt.plot(f[:1000], fft[:1000], label = \"FFT von phi\")\nplt.legend()\nplt.title(\"FFT von phi\")\nplt.xlabel(\"f in Hz\")\nplt.xlim(0, 1)\nplt.show()\nprint(\"Für die Winkelrequenz omega_0 ergibt sich: ({w_0} +- {d_w_0}) * 1/s\".format(w_0 = round(w0, 2), d_w_0 = round(d_w0, 4)))\n\n#Berechnung der natürlichen Dämpfung\nt_error = 0.01\nphi_error = 0.01\ndef phimodel(t,phi0=2.46, omega0=w0, phi1=1.35, lambda_0=0.005, c=0, d=0):\n    return phi0 * np.exp(- lambda_0 * t) * np.sin(omega0 * t + phi1) + c\n\nfit = kafe2.XYFit(xy_data=[t[:1000], phi[:1000]], model_function=phimodel) \nfit.add_error(axis='y', err_val=phi_error)\nfit.add_error(axis='x', err_val=t_error)\n#fit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n\nfit.do_fit()\nm = fit.parameter_values[3]\nd_m = fit.parameter_errors[3]\nw_fit = fit.parameter_values[1]\nd_w_fit = fit.parameter_errors[1]\nplot = kafe2.Plot(fit)\nplot.customize('data', 'label', [\"Dämpfung\"])\nplot.x_label=\"t in s\"\nplot.y_label=\"phi in rad\"\nplot.plot()\nplot.show()\nprint(\"omega_0 über Fit: (\" + str(round(w_fit, 4)) + \" +- \" +str(round(d_w_fit, 5)) + \") 1/s\")\nprint(\"omega_0 über Fourier: (\" + str(round(w0, 2)) + \" +- \" +str(round(d_w0, 3))+ \") 1/s\")\nw0 = (w0 * d_w0 + w_fit * d_w_fit) / (d_w0 + d_w_fit)\nd_w0 = np.sqrt(d_w0**2 + d_w_fit**2)\nprint(\"omega_0 gewichtet gemittelt: (\" + str(round(w0, 2)) + \" +- \" +str(round(d_w0, 3))+ \") 1/s\")\nprint(\"Für lambda_0 ergibt sich mit dem Fit: (\" + str(round(m, 4)) + \" +- \" +str(round(d_m, 5))+ \") 1/s\")","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"e5bcb2115f65665ff2ee06029f50a87c9effed87","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":999}}},"1":{"data":{"image/png":"a69f0ad4cadbcfedb01520fcbc7b7f45dc3e15a8","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":999}}},"2":{"data":{"image/png":"9d56ad8ce0452689c27fe919351df1c7848485b9","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":999}}},"3":{"data":{"image/png":"3366cbd64bffe90a1784b8c4f29105287bc84f11","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":992}}},"4":{"name":"stdout","text":"Für die Winkelrequenz omega_0 ergibt sich: (3.26 +- 0.0383) * 1/s\n"},"5":{"data":{"image/png":"4d937181e562f99371569c65d35611c851ddf992","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"6":{"name":"stdout","text":"omega_0 über Fit: (3.2465 +- 4e-05) 1/s\nomega_0 über Fourier: (3.26 +- 0.038) 1/s\nomega_0 gewichtet gemittelt: (3.26 +- 0.038) 1/s\nFür lambda_0 ergibt sich mit dem Fit: (0.0032 +- 1e-05) 1/s\n"}},"pos":8,"start":1700956144757,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956453250,"exec_count":45,"id":"f8ac8f","input":"def phi_model(t, m, omega0=w0, phi0=np.pi, Lambda=m, phi1=0, c=0):\n    return phi0  * np.exp(-Lambda * t) * np.sin(np.sqrt(omega0**2 + Lambda**2) * t + phi1) + c\n\ndef Lambda_from_k(k_):\n    return abs(np.log(k_) * w0/(2 * np.pi))\n","kernel":"python3-ubuntu","pos":15,"start":1700956453247,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956461116,"exec_count":46,"id":"eca48b","input":"names = [\"1.3_100mA.csv\", \"1.3_200mA.csv\", \"1.3_400mA.csv\", \"1.3_700mA.csv\"]\nLambdas = []\nd_Lambdas = []\nk = []\nk_err = []\nomegas = []\nd_omegas = []\nfor i in names: \n    N = 250 # number of values to be fitted / plotted\n    def peak_err(y_ax, x_ax, ind_1, ind_2, peak):\n        if y_ax[ind_1] >= y_ax[ind_2]:\n            return abs(x_ax[ind_1] - x_ax[peak])\n        else:\n            return abs(x_ax[ind_2] - x_ax[peak])\n        \n    df = pd.read_table(i, delimiter=\";\", decimal=\",\", usecols=(0,1,2,3,4,5))\n    t = df[\"Zeit t / s\"].to_numpy()\n    phi = df[\"Weg &b_A1 / rad\"].to_numpy()\n    fft = df[\"FFT fft / rad\"].to_numpy()\n    f = df[\"Frequenz f / Hz\"].to_numpy()\n    plt.plot(t, phi)\n    plt.xlabel('Zeiz t in s')\n    plt.ylabel(\"Winkel phi in rad\")\n    plt.title(\"Winkel phi in Abhängigkeit von t bei I_B: \" + i[4:-4])\n    plt.show()\n    fit = kafe2.XYFit(xy_data=[t[:N], phi[:N]], model_function=phi_model) \n    fit.add_error(axis='y', err_val=phi_error)\n    fit.add_error(axis='x', err_val=t_error)\n    fit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n    #fit.limit_parameter(name=\"m\", lower=m-d_m, upper=m+d_m)\n    #fit.add_parameter_constraint(name=\"m\", value=m, uncertainty=d_m)\n\n    fit.do_fit()\n    Lambdas.append(fit.parameter_values[3])\n    d_Lambdas.append(fit.parameter_errors[3])\n    plot = kafe2.Plot(fit)\n    plot.customize('data', 'label', [(0, \"Dämpfungsstrom: \" + i[4:-4])])\n    plot.x_label=\"t in s\"\n    plot.y_label=\"phi in rad\"\n    plot.plot()\n    plot.show()\n    \n    peaks, prop = sc.signal.find_peaks(phi, height=0.05)\n    widths = sc.signal.peak_widths(phi, peaks, rel_height=3/4, prominence_data=None, wlen=None)\n    \n    l_ips = np.ceil(np.array(widths[2]))\n    r_ips = np.floor(np.array(widths[3]))\n    \n    peak_err = [ peak_err(phi, t, int(l_ips[q]), int(r_ips[q]), peaks[q]) for q in range(len(l_ips))] \n    ka = 0\n\n    if i in names[1:]: # große Dämpfung für Datensätze 2-4\n        for j in range(1, len(peaks)):\n            ka += phi[peaks[j]] / phi[peaks[j-1]]\n        ka *= 1/(len(peaks[:]) - 1)\n        k.append(ka)\n        k_phi_errs = [(1/phi[peaks[n-1]] - phi[peaks[n+1]] / phi[peaks[n]]**2)**2 * peak_err[n]**2 for n in range(1,len(peak_err)-1)] # lineare Fehlerfortpflanzung für große Dämpfung\n        k_err.append(1/(len(peaks)-2) * np.sqrt(sum(k_phi_errs)))\n    else: # kleine Dämpfung für Datensatz 1\n        l = 10\n        ka = (phi[peaks[0]] / phi[peaks[l]])**(1/l)\n        k.append(ka)\n        k_err.append(np.sqrt( (1/(l*phi[peaks[l]]) * (phi[peaks[0]] / phi[peaks[l]])**(1/l - 1))**2 * peak_err[0]**2 + (phi[peaks[0]] / (l * phi[peaks[l]]**2 * (phi[peaks[0]] / phi[peaks[l]])**(1/l - 1))**2 * peak_err[l]**2))) # lineare Fortpflanzung für kleine Dämpfung\n\n    peaks, prop = sc.signal.find_peaks(fft, height=0.2)\n    W0 = np.pi * 2 * f[peaks[0]]\n\n    a, b, c, d = sc.signal.peak_widths(fft, peaks, rel_height=0.5, prominence_data=None, wlen=None)\n    plt.plot(f[:N], fft[:N], label = \"FFT von phi\")#, color=\"blue\")\n    plt.plot(f[peaks], fft[peaks], \"x\", label = \"Peak\")\n    plt.hlines(y=fft[peaks[0]]/2, xmin=f[int(np.floor(c[0]))], xmax=f[int(np.ceil(d[0]))], label=\"fwhm des Peaks\", color=\"red\")\n    plt.legend()\n    plt.title(\"FFT von phi bei I = \" + i[4:-4])\n    plt.xlabel(\"f in Hz\")\n    plt.show()\n    d_W0 = np.pi * 2 * (f[int(np.ceil(d[0]))] - f[int(np.floor(c[0]))]) /2\n    omegas.append(W0)\n    d_omegas.append(d_W0)\n\n","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"08af567e6b66cdc3454d5f32298d45708e1cdd6d","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":999}}},"1":{"data":{"image/png":"d8b482fecff16e2bcb7a1b10e6bc57dc6ee9505b","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"10":{"data":{"image/png":"774d407d6c59f25aa4a65c98304cf363e08492ce","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"11":{"data":{"image/png":"2bd55bc668115f300dd7047ea03b50e3db1765b8","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":990}}},"2":{"data":{"image/png":"032a45614171c4b58015d675f4c1869a31e2b1db","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":981}}},"3":{"data":{"image/png":"65bc2f8095eb6cf48e876a4aefd50bc5bd6300e8","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":999}}},"4":{"data":{"image/png":"00833457ff78f467e67f13293d4d7c52e36b5c16","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"5":{"data":{"image/png":"abeae1bb726cce1309b45c2f4e548bbb5ba6721b","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":981}}},"6":{"data":{"image/png":"2841b19ad71ca085def5238b247188623e750934","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1014}}},"7":{"data":{"image/png":"34511d37a43138345c3a58441e447b78ce9436d6","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"8":{"data":{"image/png":"136127f671fef8a0aa736fc83278d99124a13d3f","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":990}}},"9":{"data":{"image/png":"815f06ed29980255530dcdc1e29161c96c37df9b","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1012}}}},"pos":16,"start":1700956453799,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956461135,"exec_count":47,"id":"f89963","input":"for i in range(len(names)):\n    print(\"Lambda für Dämpfungsstrom: \" + names[i][4:-4] + \": ()\" + str(round(Lambdas[i], 4)) + \" +- \" +str(round(d_Lambdas[i], 5))+ \") 1/s\")","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"Lambda für Dämpfungsstrom: 100mA: ()0.0181 +- 0.00012) 1/s\nLambda für Dämpfungsstrom: 200mA: ()0.0576 +- 0.00017) 1/s\nLambda für Dämpfungsstrom: 400mA: ()0.2173 +- 0.00072) 1/s\nLambda für Dämpfungsstrom: 700mA: ()0.6447 +- 0.00472) 1/s\n"}},"pos":18,"start":1700956461126,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956461571,"exec_count":48,"id":"dbce7e","input":"I = [0.1,0.2,0.4,0.7]\nL_k = Lambda_from_k(np.array(k))\nplt.errorbar(I, Lambdas, d_Lambdas, label=\"Lambda über Fit\")\nplt.errorbar(I, L_k, k_err, label=\"Lambda über über k\")\nplt.title(\"Lambda(I)\")\nplt.xlabel(\"I in A\")\nplt.ylabel(\"Lambda in 1/s\")\nplt.legend()","kernel":"python3-ubuntu","output":{"0":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7eff4ea7ba90>"},"exec_count":48},"1":{"data":{"image/png":"c8050c4e0fe0bb492a9261d3d81543a2388fd626","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1001}}}},"pos":20,"start":1700956461167,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956461957,"exec_count":49,"id":"88c99d","input":"#plot omegas with I\nprint(d_w0)\nprint(w0)\nplt.errorbar(I, omegas, d_omegas, label=\"gemessene Frequenz\")\nplt.errorbar(I, [w0]*len(I), [d_w0]*len(I), label = \"Grundfrequenz w0\")\nplt.title(\"omega(I)\")\nplt.xlabel(\"I in A\")\nplt.ylabel(\"w in 1/s\")\nplt.legend()","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"0.038349201281049176\n3.2596821088888355\n"},"1":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7eff4e2c2020>"},"exec_count":49},"2":{"data":{"image/png":"dcad862b68ad65438ec16d029637f87d50cd15a8","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1001}}}},"pos":23,"start":1700956461602,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956462663,"exec_count":50,"id":"b017d8","input":"def lambda_von_I(I, c=1, d=0, e=0):\n    return c*(I-e)**2 + d\nlambda_err = [np.sqrt(x**2 + d_m**2) for x in d_Lambdas]\nLambdas -= m\nfit = kafe2.XYFit(xy_data=[I, Lambdas], model_function=lambda_von_I) \nfit.add_error(axis='y', err_val=lambda_err)\nfit.add_error(axis='x', err_val=0.01)\n\nfit.do_fit()\nc = fit.parameter_values[0]\nd_c = fit.parameter_errors[0]\nplot = kafe2.Plot(fit)\nplot.customize('data', 'label', [(0, \"lambda von I: \")])\nplot.x_label=\"I in A\"\nplot.y_label=\"lambda in 1/s\"\nplot.plot()\nplot.show()\nI_g = np.sqrt(w0 / c)\nd_I_g = np.sqrt( (1/c * 1 / (2 * np.sqrt(w0/c)))**2 * d_w0**2 +  (w0/c**2 * 1 / (2 * np.sqrt(w0/c)))**2 * d_c**2) # Fehlerfortpflanzung auf I_g\nprint(\"Der aperiodische Grenzfall tritt bei I = (\" + str(round(I_g, 2)) + \" +- \" + str(round(d_I_g, 3)) + \")A ein.\") ","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"721f2f57943803f0a9b17b3a97fc5db86f33b029","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"1":{"name":"stdout","text":"Der aperiodische Grenzfall tritt bei I = (1.58 +- 0.072)A ein.\n"}},"pos":25,"start":1700956461965,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956462677,"exec_count":51,"id":"f2b173","input":"Q = w0 / (2 * np.array(Lambdas))\nd_Q = [np.sqrt( (1/(2*Lambdas[l_ind]))**2 * d_w0**2 + (w0 / (2 * Lambdas[l_ind]**2))**2 * d_Lambdas[l_ind]**2) for l_ind in range(len(d_Lambdas))]\nprint(d_Q)\nfor i in range(len(d_Q)):\n    print(\"Güte Q bei I = \" + str(I[i]) + \": \" + str(round(Q[i], 2)) + \" +- \" + str(round(d_Q[i], 3)))","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"[1.5707068783764058, 0.36476543375864595, 0.09315596524561282, 0.03525311581394407]\nGüte Q bei I = 0.1: 109.67 +- 1.571\nGüte Q bei I = 0.2: 30.0 +- 0.365\nGüte Q bei I = 0.4: 7.61 +- 0.093\nGüte Q bei I = 0.7: 2.54 +- 0.035\n"}},"pos":28,"start":1700956462665,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956468100,"exec_count":52,"id":"1ed510","input":"file_names = [\"2.1_200mA_1.csv\", \"2.1_200mA_2.csv\",\"2.1_200mA_3.csv\",\"2.1_200mA_3.8.csv\",\"2.1_200mA_4.csv\",\"2.1_200mA_4.2.csv\",\"2.1_200mA_4.4.csv\",\"2.1_200mA_4.6.csv\",\"2.1_200mA_5.csv\",\"2.1_200mA_6.csv\",\"2.1_200mA_7.csv\",\"2.1_200mA_8.csv\",\"2.1_200mA_9.csv\", \"2.1_400mA_1.csv\", \"2.1_400mA_2.csv\",\"2.1_400mA_3.csv\",\"2.1_400mA_3.8.csv\",\"2.1_400mA_4.csv\",\"2.1_400mA_4.2.csv\",\"2.1_400mA_4.4.csv\",\"2.1_400mA_4.6.csv\",\"2.1_400mA_5.csv\",\"2.1_400mA_6.csv\",\"2.1_400mA_7.csv\",\"2.1_400mA_8.csv\",\"2.1_400mA_9.csv\",]\namplitude = []\nU_amplitude = []\nOmegas = []\nd_Omegas = []\nphases = []\npeak_finder_width = 0.015\nfor file in file_names:\n    \n    df = pd.read_table(file, delimiter=\";\", decimal=\",\", usecols=(0,1,2,3,4))\n    #t = df[\"Zeit t / s\"].to_numpy()\n    min_size_t = 250\n    t = df[\"Zeit t / s\"].to_numpy()[-min_size_t:]\n    f = df[\"Frequenz f / Hz\"].to_numpy()\n    U = df[\"Spannung U_B1 / V\"].to_numpy()[-min_size_t:]\n    phi = df[\"Weg &b_A1 / rad\"].to_numpy()[-min_size_t:]\n    fft = df[\"FFT fft / rad\"].to_numpy()\n    \n    #erste Anpassungen von möglichen Abweichungen der Winkel\n\n    U -= np.mean(U)#U_discr\n    phi -= np.mean(phi)\n    \n    #Amplitude for phi\n    max_peaks=sc.signal.find_peaks(phi, peak_finder_width)[0]\n    max_amplitude = np.sum(phi[max_peaks])/len(max_peaks)\n    min_peaks=sc.signal.find_peaks(-phi, peak_finder_width)[0]\n    min_amplitude = np.sum(phi[min_peaks])/len(min_peaks)\n    amplitude.append((max_amplitude-min_amplitude)/2)\n    #print(max_amplitude-min_amplitude)\n            \n    \n    #Amplitude for U\n    U_max_peaks=sc.signal.find_peaks(U, peak_finder_width)[0]\n    U_max_amplitude = np.sum(U[U_max_peaks])/len(U_max_peaks)\n    U_min_peaks=sc.signal.find_peaks(-U, peak_finder_width)[0]\n    U_min_amplitude = np.sum(U[U_min_peaks])/len(U_min_peaks)\n    U_amplitude.append((U_max_amplitude-U_min_amplitude)/2)\n    \n    \n\n    # berechnen der tatsächlichen Frequenz\n    new_f = int(len(f)/5 * 0.01)\n    peaks, prop = sc.signal.find_peaks(fft[new_f:], max(fft)/4)\n    peaks += new_f\n    W0 = np.pi * 2 * f[peaks[-1]]\n    Omegas.append(W0)\n    a, b, c, d = sc.signal.peak_widths(fft, peaks, rel_height=0.25, prominence_data=None, wlen=None)\n\n    #plt.plot(f[peaks], fft[peaks], \"x\", label = \"Peak\")\n    #plt.hlines(y=fft[peaks[-1]]/2, xmin=f[int(np.floor(c[-1]))], xmax=f[int(np.ceil(d[-1]))], label=\"fwhm des Peaks\")\n    #plt.plot(f, fft)\n    #plt.show()\n    d_W0 = np.pi * 2 * (f[int(np.ceil(d[-1]))] - f[int(np.floor(c[-1]))]) /2\n    d_Omegas.append(d_W0)\n\n    U /= np.std(U) #Mit standardabewichung normieren um Phase über Kovarianz zu bestimmen\n    phi /= np.std(phi)#\n    cov_mat = np.cov(phi, U, bias=True) # bias set to true to avoid Nan values\n    phase = np.arccos((cov_mat[0,1]))\n    #if np.isnan(phase):\n     #   phase = 0\n    phases.append(phase)\n\n    if max_amplitude-min_amplitude>6:\n        print(phase)\n        plt.plot(t, phi, label=\"phi\")\n        plt.plot(t, U, label = \"U\")\n        plt.legend()\n        plt.title(\"Zeitlicher Verlauf des Phasenwinkels\")\n        plt.xlabel(\"t in s\")\n        plt.ylabel(\"Phi in rad\")\n        plt.plot(t[min_peaks],phi[min_peaks], \".\")\n        plt.plot(t[max_peaks],phi[max_peaks], \".\")\n        plt.plot(t[U_min_peaks],U[U_min_peaks], \".\")\n        plt.plot(t[U_max_peaks],U[U_max_peaks], \".\")\n        plt.show()\n\n\n\n#f= np.arra([1,2,3,3.8,4,4.2,4.4,4.6,5,6,7,8,9]) / (2)\nAmps = [amplitude[:13], amplitude[13:]]\nOms = [Omegas[:13], Omegas[13:]]\nd_Oms = [d_Omegas[:13], d_Omegas[13:]]\nPhases = [phases[:13], phases[13:]]\nStrom = [\"200mA\", \"400mA\"]\nw0 = w0_\nd_w0 = d_w0_\n\n\n\"\"\"\nplt.plot(f, amplitude[:13])\nplt.title(\"Zeitlicher Verlauf des Phasenwinkels\")\nplt.xlabel(\"t in s\")\nplt.ylabel(\"Phi in rad\")\nplt.show()\n\nplt.plot(f, amplitude[11:])\nplt.title(\"Zeitlicher Verlauf des Phasenwinkels\")\nplt.xlabel(\"t in s\")\nplt.ylabel(\"Phi in rad\")\nplt.show()\n\"\"\"\n\ndef res_model(w, omega0, Theta, Phi = 0.017, Lambda=0.2, c=0, d=0):\n    return Phi/(Theta * np.sqrt((w0**2-(w-d)**2)**2+(2*Lambda*w)**2)) + c\n\ndef phase_model(w, omega0, Lambda=0.135, c=0, d=0):\n    return ((np.arctan( 2 * Lambda * (w-d) / (omega0**2 - (w-d)**2))) + np.pi)%np.pi + c\n\nlambdas=[]\nd_lambdas=[]\nfor i in range(len(Amps)): \n    \n    fit = kafe2.XYFit(xy_data=[Oms[i], Amps[i]], model_function=res_model) \n    fit.add_error(axis='y', err_val=phi_error)\n    fit.add_error(axis='x', err_val=d_Oms[i])\n    fit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n    fit.add_parameter_constraint(name=\"Theta\", value=theta, uncertainty=d_theta)\n    fit.limit_parameter(name=\"Theta\", lower=0, upper=2*theta)\n    fit.limit_parameter(name=\"Phi\", lower=0)\n\n    fit.limit_parameter(name=\"Lambda\", lower=0, upper=1)\n    fit.do_fit()\n    lambda_1 = fit.parameter_values[3]\n    d_lambda_1 = fit.parameter_errors[3]\n    \n    plot = kafe2.Plot(fit)\n    plot.customize('data', 'label', [\"Antwortamplitude phi(omega) bei Dämpfungsstrom: \" + Strom[i]])\n    plot.x_label=\"Omega in 1/s\"\n    plot.y_label=\"phi in rad\"\n    plot.plot()\n    plot.show()\n    \n    fit = kafe2.XYFit(xy_data=[Oms[i], Phases[i]], model_function=phase_model) \n    fit.add_error(axis='y', err_val=0.1)\n    fit.add_error(axis='x', err_val=d_Oms[i])\n    fit.add_parameter_constraint(name=\"omega0\", value=w0, uncertainty=d_w0)\n    fit.limit_parameter(name=\"Lambda\", lower=0, upper=1)\n    fit.limit_parameter(name=\"s\", lower=0, upper=1)\n    fit.do_fit()\n    lambda_2 = fit.parameter_values[1]\n    d_lambda_2 = fit.parameter_errors[1]\n    \n    plot = kafe2.Plot(fit)\n    plot.customize('data', 'label', [\"Phase bei Dämpfungsstrom: \" + Strom[i]])\n    plot.x_label=\"Omega in 1/s\"\n    plot.y_label=\"Phase in rad\"\n    plot.plot()\n    plot.show()\n    \n    lambda_ = (lambda_1 * d_lambda_1 + lambda_2 * d_lambda_2) / (d_lambda_1 + d_lambda_2)\n    d_lambda_ = np.sqrt(d_lambda_1**2 + d_lambda_2**2)\n    lambdas.append(lambda_)\n    d_lambdas.append(d_lambda_)","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"ad47b2ee5aa4b6d2b7b521ac9469e5ec82ed9fde","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"1":{"data":{"image/png":"ec0e7f54d6eba6498e563dad0a9bda0e99bf3f6a","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"2":{"data":{"image/png":"422adf8d996b01a35591bf97daad86da49b3527b","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":490,"width":1188}}},"3":{"data":{"image/png":"8763bc7498fb64b9c1584eeb5a1438d2898ec3d3","text/plain":"<Figure size 1200x500 with 2 Axes>"},"metadata":{"image/png":{"height":489,"width":1188}}}},"pos":31,"start":1700956464456,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956468531,"exec_count":53,"id":"1a4b20","input":"lines = {'linestyle': 'line'}\n#plt.rc('lines', **lines)\nprint(I)\nI_n = [0.200, 0.400]\nQ_n = w0 / (2 * np.array(lambdas))\nd_Q_n = [np.sqrt( (1/(2*lambdas[l_ind]))**2 * d_w0**2 + (w0 / (2 * lambdas[l_ind]**2))**2 * (d_lambdas[l_ind])**2) for l_ind in range(len(d_lambdas))]\nprint(I_n, Q_n)\nfor i in range(len(I_n)):\n    print(\"Güte Q bei R = \" + str(I_n[i]) + \": \" + str(round(Q_n[i], 2)) + \" +- \" + str(round(d_Q_n[i], 3)))\nplt.plot(I_n, Q_n, \"x\")\nplt.errorbar(I_n, Q_n, d_Q_n, label = \"Güte in Aufgabe 2.1\")\nplt.errorbar(I, Q, d_Q, label=\"Güte in Aufgabe 1.3\")\nplt.xlabel(\"Dämpfungsstrom I in A\")\nplt.ylabel(\"Güte Q\")\nplt.legend()\nplt.title(\"Vergleich der Güte aus Afugabe 2.1 und 1.3\")","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"[0.1, 0.2, 0.4, 0.7]\n[0.2, 0.4] [23.99878888  6.39019344]\nGüte Q bei R = 0.2: 24.0 +- 9.389\nGüte Q bei R = 0.4: 6.39 +- 1.235\n"},"1":{"data":{"text/plain":"Text(0.5, 1.0, 'Vergleich der Güte aus Afugabe 2.1 und 1.3')"},"exec_count":53},"2":{"data":{"image/png":"4214ba878c72b436b4c6891a1c22ccbd70e7f7e4","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1005}}}},"pos":33,"start":1700956468122,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956584140,"exec_count":59,"id":"76008c","input":"#geschätzte Unsicherheit für die Resonanzbreite: 20% des Wertes, die Unsicherheit auf omega_res wurde mit der halben Breite auf halber Höhe der Resonanzkurve abgeschätzt.\nprint(\"Für die Güte über die Stromstärke wurden folgene Werte ermittelt:\")\nfor i in range(len(file_names)):\n    print(\"Güte Q bei R = \" + file_names[i][4:-4] + \": \" + str(round(Q[i], 2)) + \" +- \" + str(round(d_Q[i], 3)))","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"Für die Güte über die Stromstärke wurden folgene Werte ermittelt:\nGüte Q bei R = 8.2ohm: 109.67 +- 1.571\nGüte Q bei R = 47ohm: 30.0 +- 0.365\nGüte Q bei R = 100ohm: 7.61 +- 0.093\n"}},"pos":41,"start":1700956584132,"state":"done","type":"cell"}
{"cell_type":"code","end":1700956584871,"exec_count":60,"id":"a89598","input":"print(\"Für die Güte über die Überhöhungsspannungen am Kondensator wurden folgene Werte ermittelt:\")\nfor i in range(len(file_names)):\n    print(\"Güte Q bei R = \" + file_names[i][4:-4] + \": \" + str(round(Q_Ua[i], 2)) + \" +- \" + str(round(d_Q_Ua[i], 3)))\nprint(\"\")\nprint(\"Für die Güte über die Überhöhungsspannungen an der Spule wurden folgene Werte ermittelt:\")\nfor i in range(len(file_names)):\n    print(\"Güte Q bei R = \" + file_names[i][4:-4] + \": \" + str(round(Q_Ub[i], 2)) + \" +- \" + str(round(d_Q_Ub[i], 3)))","kernel":"python3-ubuntu","output":{"0":{"name":"stdout","text":"Für die Güte über die Überhöhungsspannungen am Kondensator wurden folgene Werte ermittelt:\nGüte Q bei R = 8.2ohm: 4.6 +- 0.92\nGüte Q bei R = 47ohm: 4.13 +- 0.825\nGüte Q bei R = 100ohm: 2.99 +- 0.599\n\nFür die Güte über die Überhöhungsspannungen an der Spule wurden folgene Werte ermittelt:\nGüte Q bei R = 8.2ohm: 4.6 +- 0.92\nGüte Q bei R = 47ohm: 4.14 +- 0.828\nGüte Q bei R = 100ohm: 3.02 +- 0.603\n"}},"pos":43,"start":1700956584867,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":62,"id":"b57384","input":"import pandas as pd\nQ_I = []\nd_Q_I = []\nQ_Ua = []\nd_Q_Ua = []\nQ_Ub = []\nd_Q_Ub = []\nfile_names = [\"2.2_8.2ohm.csv\", \"2.2_47ohm.csv\", \"2.2_100ohm.csv\"]\n#Zeit t / ms;Spannung U_2 / V;Spannung U_B1 / V;Stromstärke I_2 / A;Phasenverschiebung &j_2 / ;f2 f2;n0 n0;f0 f0;f1 f1;Spannung U_A1 / V;Z Z\nfor file in file_names: \n    df = pd.read_table(file, delimiter=\";\", decimal=\",\")\n    min_size_t = 250\n    t = df[\"Zeit t / ms\"].to_numpy() / 1000\n    U_2 = df[\"Spannung U_2 / V\"].to_numpy()\n    U_B1 = df[\"Spannung U_B1 / V\"].to_numpy()\n    I = df[\"Stromstärke I_2 / A\"].to_numpy()\n    d_phi = df[\"Phasenverschiebung &j_2 / °\"].to_numpy() +90\n    f = df[\"f2 f2\"].to_numpy()\n    n0 = df[\"n0 n0\"].to_numpy()\n    f0 = df[\"f0 f0\"].to_numpy()\n    f1 = df[\"f1 f1\"].to_numpy()\n    U_A1 = df[\"Spannung U_A1 / V\"].to_numpy()\n    Z = df[\"Z Z\"].to_numpy()\n    \n    # find peaks in I to calculate fwhm for Q\n    peaks, prop = sc.signal.find_peaks(I)\n    f0_exp = f[peaks[0]]\n    height_for_Q = 1/np.sqrt(2)\n    a, b, c, d = sc.signal.peak_widths(I, peaks, rel_height=1-height_for_Q, prominence_data=None, wlen=None)\n    fwa_sqrt2 = (f[int(np.ceil(d[0]))] - f[int(np.floor(c[0]))]) \n    d_fwa_sqrt2 = fwa_sqrt2 * 0.2\n    a, b, c, d = sc.signal.peak_widths(I, peaks, rel_height=0.5, prominence_data=None, wlen=None)\n    err_d_f0_exp = (f[int(np.ceil(d[0]))] - f[int(np.floor(c[0]))]) / 2\n    #Q.append(f0_exp / fwa_sqrt2)\n    #d_Q.append(np.sqrt(err_d_f0_exp**2 / fwa_sqrt2**2 + f0_exp**2 * d_fwa_sqrt2 **2 / fwa_sqrt2**4))\n    \n    \n    #plot Strom und Impedanz\n    fig, ax1 = plt.subplots()\n    ax2 = ax1.twinx()\n    #ax1.plot(f[peaks], I[peaks], \"x\", label = \"Peak\")\n    #ax1.hlines(y=I[peaks[0]]*height_for_Q, xmin=f[int(np.floor(c[0]))], xmax=f[int(np.ceil(d[0]))], label=\"fwhm des Peaks\")\n    ax1.plot(f, I, 'g-', label=\"I_omega in A\")\n    ax2.plot(f, Z, 'b-', label=\"Imepdanz Z in Ohm\")\n\n    ax1.set_xlabel('Frequenz in Hz')\n    ax1.set_ylabel('Strom I in A', color='g')\n    ax2.set_ylabel('Impedanz Z in Ohm ', color='b')\n    plt.title(\"Strom und Impedanz bei R = \" + file[4:-4])\n    plt.show()\n    \n    \n    U0 = np.mean(U_2)\n    d_U0 = np.std(U_2)\n    \n    peaks_a, prop_a = sc.signal.find_peaks(U_A1)\n    peaks_b, prop_b = sc.signal.find_peaks(U_B1)\n    U0_a = U_A1[peaks_a[0]]\n    U0_b = U_B1[peaks_b[0]]\n    #print(U0_a, U0_b)\n    \n    d_U0_a = U0_a * 0.2\n\n    d_U0_b = U0_b * 0.2\n    Q_Ua.append(U0_a / U0)\n    Q_Ub.append(U0_b / U0)\n    \n    d_Q_Ua.append(np.sqrt( (d_U0_a / U0)**2 + (U0_a * d_U0 / U0**2)**2))\n    d_Q_Ub.append(np.sqrt( (d_U0_b / U0)**2 + (U0_b * d_U0 / U0**2)**2))\n    \n    \n    # plot Spannung\n    plt.plot(f, U_A1, label=\"Spannung an Kondensator\")\n    plt.plot(f, U_B1, label=\"Spannung an Spule\")\n    plt.plot(f, U_2, label=\"Erregerspannung\")\n    plt.legend()\n    plt.xlabel('Frequenz f in Hz')\n    plt.ylabel(\"Spannung U in V\")\n    plt.title(\"Resonanzüberhöhung an Spule und Kondensator bei R = \" + file[4:-4])\n    plt.show()\n    \n    \n    plt.plot(f, d_phi)\n    plt.xlabel('Frequenz f in Hz')\n    plt.ylabel(\"Phasendifferenz phi in °\")\n    plt.title(\"Phasendifferenz bei R = \" + file[4:-4])\n    plt.show()\n    \n","kernel":"python3-ubuntu","output":{"0":{"data":{"image/png":"6f884932fe12decf849e2b48dab287aadc48e1c4","text/plain":"<Figure size 1200x700 with 2 Axes>"},"metadata":{"image/png":{"height":623,"width":1074}}},"1":{"name":"stdout","text":"9.751158905484 9.75412989456261\n"},"10":{"data":{"image/png":"73506c871a18afbb9902d55451d372c36c8fb5e5","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":988}}},"11":{"data":{"image/png":"fedd4c67b12d67ed47e0b8a8a1dc4550d41275fa","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1005}}},"2":{"data":{"image/png":"46a9a9dcfcf71993a4b302816b3293d2d7cd0879","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":996}}},"3":{"data":{"image/png":"43100bcfaf6bf9a83293ee291dcfcd2287e8f675","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1005}}},"4":{"data":{"image/png":"98a9c593ccd66d55e6dd1cd7adf93d2422848e4e","text/plain":"<Figure size 1200x700 with 2 Axes>"},"metadata":{"image/png":{"height":623,"width":1083}}},"5":{"name":"stdout","text":"8.75175696646108 8.77499002848436\n"},"6":{"data":{"image/png":"8abcb0c4a1de7b906ebc52cdb5ce7fa8bc5c25e9","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":988}}},"7":{"data":{"image/png":"a4f0b7fa36ddea1b2c2722cc6a892f70013ade39","text/plain":"<Figure size 1200x700 with 1 Axes>"},"metadata":{"image/png":{"height":623,"width":1005}}},"8":{"data":{"image/png":"560bba46e9cb1d2964558e56b0857d3dfca27027","text/plain":"<Figure size 1200x700 with 2 Axes>"},"metadata":{"image/png":{"height":623,"width":1092}}},"9":{"name":"stdout","text":"6.34669599082861 6.39660456805015\n"}},"pos":39,"state":"done","type":"cell"}
{"cell_type":"code","id":"84b037","input":"","pos":6,"type":"cell"}
{"cell_type":"markdown","exec_count":0,"id":"acd188","input":"Es ist festzustellen, dass die Güte in den beiden Methoden nur für kleine Werte des Widerstands ungefähr gleich ist, für große Werte sind große Unterschiede festzustellen.","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"07c119","input":"---\n\n**Beanstandungen:**\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n%\\text{\\vspace{10cm}}\n\\end{equation*}\n\n<br>\nTestiert am: __________________ Testat: __________________","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"0bed06","input":"Wir haben gemessen, dass bei I =1,5 +- 0.1A der aperiodische Grenzfall eintrat. Wir können den berechneten Wert also gerade so bestätigen, da sich die Unsicherheiten auf beide Werte überschneiden.\n\n---\n\n","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"11dc1c","input":"Das Modell sagt voraus:\n$$\n\\varphi_{0} = \\frac{\\Phi/\\Theta}{\\sqrt{\\left(\\omega_{0}^{2}-\\Omega^{2}\\right)^{2}+\\left(2\\,\\lambda\\,\\Omega\\right)^{2}}};\n$$\n$$\n\\phi = \\arctan\\left(\\frac{2\\,\\lambda\\,\\Omega}{\\omega_{0}^{2}-\\Omega^{2}}\\right).\n$$\nDies wird nun mit den gemessenen Daten mittels eines Fits überrprüft.","pos":30.5,"type":"cell"}
{"cell_type":"markdown","id":"17c977","input":"**Lösung:**\n\n---\n\n","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"1ba6a8","input":"Die lineare Dämpfung modellieren wir mit einer Funktion der Form $f(t) = f_0 e^{-\\lambda_0 t} sin(\\omega t - \\phi_0) $. Zusätzlich bestimmen wir die Eigenfrequenz $\\omega_0$ durch den Peak in der Fourietransformierten. Die Unsicherheit auf $\\omega_0$ ist mit dieser Methode durch die halbe Breite bei halber Höhe gegeben. ","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"1c3ad3","input":"Die Lambdas ergeben sich zu:","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"1dce55","input":"**Lösung:**\n\n\n\n---","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"2c3dd2","input":"### Aufgabe 2.2: Elektrische erzwungene Schwingung\n\nFühren Sie die folgenden Aufgaben für drei verschiedene Widerstände $R$ durch:\n\n - Stellen Sie $I_{\\Omega}$ und $Z(\\Omega)$ in einer gemeinsamen Abbildung dar. \n - Bestimmen Sie $Q(R)$ aus der Resonanzbreite. \n - Demonstrieren Sie die Resonanzüberhöhung an Spule und Kondensator, indem Sie die Spannungsverläufe an Spule und Kondensator zusammen mit der anliegenden Spannung als Funktion von $\\Omega$ darstellen. \n - Bestimmen Sie auch hieraus $Q(R)$ und vergleichen Sie die ermittelten Werte im Rahmen der sich ergebenden Unsicherheiten. \n - Stellen Sie $\\Delta\\phi(\\Omega)$ dar.\n\n---","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"3541c0","input":"Es ist anzumerken, dass für beide Ströme in den Fits der Phase, als auch der Amplitude unabhängig der Dämpfungsparameter $\\Lambda$ gefittet wurde. In beiden Messreihen, haben beide Fits innerhalb der Unsicherheit den gleichen Wert für $\\Lambda$ ergeben. Dies weist auf Konsistenz des Modells hin. Die Fits lassen alle darauf schließen, dass das Modell oben akzeptiert werden kann.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"570db3","input":"**Lösung:**\n\nDie Daten werden aus der Datei eingelesen. Maximas, die benötigt werden, werden mit $scipy.signal.find\\_peaks$ bestimmt.\n\n---","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"66f1f4","input":"## Aufgabe 2: Erzwungene Schwingung\n\n**Hinweise zu allen hier durchzuführenden Messungen finden Sie in der Datei [Hinweise-Aufgabe-2.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/tree/main/Resonanz/doc/Hinweise-Aufgabe-2.md).**\n\n### Aufgabe 2.1: Mechanische erzwungene Schwingung\n\n- Nehmen Sie Resonanzkurven $\\varphi(\\Omega)$ für mindestens zwei verschiedene Ströme $I_{\\mathrm{B}}$ auf. Diskutieren Sie den Verlauf sowohl der Amplitude $\\varphi_{0}$, als auch der Phasenverschiebung $\\Delta\\phi$. Bestimmen Sie hierzu $\\Delta\\phi$ in drei Bereichen:\n  - möglichst weit unterhalb;\n  - möglichst weit oberhalb; und\n  - bei der Resonanzfrequenz.\n- Vergleichen Sie den Verlauf der gemessenen Resonanzkurven mit Ihrer Erwartung. \n- Bestimmen $Q(I_{\\mathrm{B}})$ und vergleichen Sie Ihre Ergebnisse mit den Ergebnissen aus Aufgabe 1.3.   \n\n---\n\n","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"6adf92","input":"Diskussion:\n1. $\\Delta\\Phi < \\omega_0$:\nDer Phasenunterschied ist sehr klein, d.h. das Pendel schwingt nicht \"weit hinter dem Antrieb\". Hier ist in beiden Messungen eine kleine, aber nicht verschwindende Amplitude zu messen. Je größer die Phase wird, desto größer wird hier die Amplitude\n2. $\\Delta\\Phi \\approx \\frac{\\pi}{2}$:\nHier gilt $\\Omega \\approx \\omega_0$. Es ist ein Phasensprung zu beobachten. In einem relativ kleinen Frequenzbereich springt die Phase von $0$ auf $\\pi$.  Bei dem kleinen Dämpfungsstrom ist ein schärferer Sprung zu beobachten. Die Amplitude steigt auf ihr Maximum bei der Resonanzfrequenz $\\Omega_{Res} \\approx \\omega_0$.\n3. $\\Delta\\Phi < \\omega_0$:\nFalls der Phasenunterschied weiter vergrößert wird, so fällt die Amplitude ungefähr exponentiell ab und nähert sich null. Das Pendel schwingt dann gegenphsaig zur antreibenden Kraft mit sehr kleiner / verschwindender Amplitude.","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"78f616","input":"### Aufgabe 1.3: Schwingung mit äußerer Dämpfung\n\nDie Drehbewegung des Pohlschen Rads kann durch eine [Wirbelstrombremse](https://de.wikipedia.org/wiki/Wirbelstrom) zusätzlich von außen gedämpft werden.\n\n- Bestimmen Sie $\\varphi(t)$ für mindestens vier verschiedene Ströme $I_{\\mathrm{B}}$ der Wirbelstrombremse.\n- Ermitteln Sie $\\lambda(I_{\\mathrm{B}})$ durch Anpassung Ihres Modells aus Aufgabe 1.1 an die aufgezeichneten Daten. \n- Bestimmen Sie $\\lambda(I_{\\mathrm{B}})$ zusätzlich aus dem Dämpfungsverhältnis $\\kappa$. Wählen Sie hierzu, je nach Wert von $I_{\\mathrm{B}}$ eine geeignete Anzahl $n$ von Perioden der Schwingung.\n- Erwarten Sie eine Abhängigkeit $\\omega(I_{\\mathrm{B}})$? Begründen Sie Ihre Antwort und überprüfen Sie sie mit den aufgezeichneten Daten. \n- Erwarten Sie eine Abhängigkeit $\\lambda(I_{\\mathrm{B}})$? Begründen Sie Ihre Antwort und überprüfen Sie sie mit den aufgezeichneten Daten. Korrigieren Sie hierzu $\\lambda(I_{\\mathrm{B}})$ auf die zuvor bestimmte intrinsische Dämpfung $\\lambda_{0}$ \\($\\lambda(I_{\\mathrm{B}})\\to \\hat{\\lambda}(I_{\\mathrm{B}})$\\). \n- Bestimmen Sie aus dem Verlauf von $\\hat{\\lambda}(I_{\\mathrm{B}})$ den Wert von $I_{\\mathrm{B}}(\\hat{\\lambda}=\\omega_{0})$ für den der aperiodische Grenzfall eintritt. Vergewissern Sie sich experimentell von der Richtigkeit von $I_{\\mathrm{B}}(\\hat{\\lambda}=\\omega_{0})$. \n- Berechnen Sie aus $\\omega_{0}$ und $\\hat{\\lambda}(I_{\\mathrm{B}})$ die Güte $Q(I_{\\mathrm{B}})$ des Pohlschen Rads.  \n\n---\n\n","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"88144b","input":"### Aufgabe 1.2: Bestimmung des Trägheitsmoments $\\Theta$\n\nBestimmen Sie das Trägheitsmoment $\\Theta$ des Drehpendels. Gehen Sie dabei wie folgt vor:\n\n - Bestimmen Sie die Winkelrichtgröße $D$ der im Pohlschen Rad verbauten Schneckenfeder. Messen Sie hierzu die Winkelauslenkung des Drehpendels (in beiden Drehrichtungen), indem Sie mit Hilfe eines Fadens geeignete Gewichte so an den Zeiger des Pendels anhängen, dass der Faden durch die Randnut bei $r = r_{a}$ läuft. Bestimmen Sie $\\Theta$ aus der Gleichung $$\\omega_{0} = \\sqrt{\\frac{D}{\\Theta}}$$.\n - Vergleichen Sie das Ergebnis, im Rahmen seiner Unsicherheiten mit Ihrer Erwartung aus einer einfachen geometrischen Abschätzung. \n\n---","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"91ae33","input":"DIe Güte ist definiert als $ Q= \\frac{\\omega}{2\\,\\lambda}$.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"9289d4","input":"Der Graph zeigt, dass über beide Methoden Lambda im Rahmen der Unsicherheit den gleichen Wert hat. Bei der zweiten Methode ist die Grenze zwischen schwacher und starker Dämpfung jedoch nicht eindeutig charakterisiert, was zu weiteren hier nicht beachteten Unsicherheiten führen kann. Für den erste Wert wurde hier eine schwache Dämpfung angenommen, für die restlichen eine stärkere. Es denkbar, dass für $I = 0.2 A$ die Annahme einer schwachen Dämpfung sinnvoll wäre, wir haben uns hier jedoch dagegen entschieden.","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"a842a3","input":"Name: Aichert Vorname: Julius E\\-Mail: uhoeb@student.kit.edu\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nName: Achtner Vorname: Martin E-Mail: urrvl@student.kit.edu\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nGruppennummer: Mo01\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nBetreuer: __________________\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nVersuch durchgeführt am: __________________\n\n","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"af5f99","input":"Die Phase wurde bei den Strömen $I_B = [0.2A, 0.4A] $ aufgenommen. Die Phase kann über den arccos der Kovarianz zwischen zwei Schwingungen bestimmt werden, wenn diese vorher mit ihrer Standardabweichung normiert wurden. Um die Frequenz zu bestimmen, bei denen die Daten aufgenommen wurde, werden wieder die Peaks der Fourietransformierten bestimmt.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"bbe8f2","input":"# Fakultät für Physik \n\n## Physikalisches Praktikum P1 für Studierende der Physik\n\nVersuch P1-12, 22 (Stand: Oktober 2023)\n\n[Raum F1-21](https://labs.physik.kit.edu/img/Praktikum/Lageplan_P1.png)\n\n# Resonanz","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"c4ec32","input":"Für die Güte über die Spannungsüberhöhung gilt: $Q = \\frac{|U_{C}(\\omega_{0})|}{U_0} $. Die Unsicherheit auf $|U_{C}(\\omega_{0})|$ wurde auf 20% geschätzt, die Unsicherheit von $U_0$ wurde mit der Funktion $np.std(U0) $ bestimmt.","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"c6d001","input":"**Lösung:**\n\nWir haben die Auslenkung des Pohlschen Pendels mit drei verschiedenen Gewichten, 5g, 10g, 20g, in beide Richtungen gemessen. Damit konnten wir über $F_g = mg = F_{Sp} = Ds$ Die Federkonstante bestimmen und damit nach obiger Formel das Trägheitsmoment $\\Theta$. Die Unsicherheit auf Theta ergibt sich nach dem Fehlerforpflanzungsgesetz.\n\n---","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"c80a8b","input":"Es ist zu erkennen, dass die Güte für große Ströme ungefähr gleich ist, bei kleinen Strömen weicht die Güte jedoch ab, hier ist die neue Güte etwas kleiner, als die alte.","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"e571d9","input":"Wir haben $\\varphi(t)$ für vier verschiedene Ströme $I_B = [0.1A, 0.2A, 0.4A, 0.7A]$ aufgezeichnet. Die Winkelfrequenz wird wie in Aufgabe 1.1 mit der zweiten Möglichkeit über die Fourietransformierte bestimmt.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"f3678c","input":"Um die Güte Q zu bestimmen, wird die volle Breite der Resonanzkurve der Stromstärke auf der Höhe $\\frac{1}{\\sqrt2}$ berechnet. Für Q gilt dann $ Q = \\frac{\\Omega_{\\mathrm{res}}}{\\Delta\\Omega} $","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"f5a5b0","input":"# Durchführung\n\n## Aufgabe 1: Freie Schwingung\n\n**Hinweise zu allen hier durchzuführenden Messungen finden Sie in der Datei [Hinweise-Aufgabe-1.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/tree/main/Resonanz/doc/Hinweise-Aufgabe-1.md).**\n\n### Aufgabe 1.1: Schwingung ohne äußere Dämpfung\n\nLenken Sie das [Pohlsche Rad](https://de.wikipedia.org/wiki/Pohlsches_Rad) aus und stellen Sie mit Hilfe des CASSY Datennahmesystems die folgenden Größen geeignet dar: \n\n - Zeitlicher Verlauf des Phasenwinkels, $\\varphi(t)$;\n - Zeitlicher Verlauf der Winkelgeschwindigkeit, $\\omega(t)$;\n - Stellen Sie den Schwingungsvorgang in einem [Phasenraumportrait](https://de.wikipedia.org/wiki/Phasenraum) $(\\varphi,\\,\\omega)(t)$ dar. \n\nDer Schwingungsvorgang ist auch ohne äußere Dämpfung nicht dämpfungsfrei. Passen Sie ein Modell mit linearer Dämpfung an die Verteilung $\\varphi(t)$ an und bestimmmen Sie daraus die Eigenfrequenz $\\omega_{0}$ und die Dämpfung $\\lambda_{0}$ der Schwingung.  \n\n\n---\n\n","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"f6f8c7","input":"Wir erwarten einen quadratischen Zusammenhang der Frequenz mit dem Bremsstrom $I_B$. Dies folgt aus der Lenzschen Regel. Um die Abhängigkeit $\\lambda$ von $I_B$ zu bestimmen, muss diese um die in Aufgabe 1.1 bestimmte lineare Reibung bereinigt werden. Dies geschieht durch eine einfach Subtraktion: $\\lambda(I_{\\mathrm{B}}) \\to \\hat{\\lambda}(I_{\\mathrm{B}}) = \\lambda(I_{\\mathrm{B}})-\\lambda_{0}$","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"f8e6a0","input":"Über Hinweis bestimmtes Trägheitsmoment: $\\Theta \\approx 0.00139 \\ kg \\ m^2$. Wir konnten also einen akzeptablen Wert ermitteln.","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"fbc098","input":"Wir erwarten, dass $w$ nur geringfügig von dem Dämpfungsstrom abhängt. Mathematisch verschiebt sich die Frequenz zwar: $\\omega = \\sqrt{\\omega_{0}^{2}-\\lambda^{2}}$, dies ist jedoch vernachlässigbar klein. Der Effekt wird nur für große $\\lambda$ relevant, dann jedoch ist die Dämpfung so stark, dass fast keine Schwingung mehr messbar ist. Dies zeigt sich unten durch die große Unsicherheit für große Dämpfungsströme. Man hätte die gemessenen Frequenzen auch mit dem Fit bestimmen können, dann sind die Unsicherheiten jedoch nur sehr klein, was bei großer Dämpfung nicht sehr realistisch ist, da es fast keine messbaren Perioden gibt. Die Fouriertransformation liefert in der Hinsicht ein besseres Ergebniss.","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"fd68b7","input":"Es existiert eine zweite  Möglichkeit, Lambda zu bestimmen:\nMit $T = 2\\pi \\omega_0$ gilt\n$$\n\\lambda = -\\frac{\\ln\\kappa}{T}\n$$\nWobei für $\\kappa$ gilt:\n$$\n\\kappa = \\frac{1}{n}\\sum\\limits_{j=1}^{n}\\frac{\\varphi_{j}}{\\varphi_{j-1}}\\qquad\\text{(große Dämpfung)} \n$$\n$$\n\\kappa = \\sqrt[n]{\\frac{\\varphi_{0}}{\\varphi_{n}}}\\qquad\\text{(kleine Dämpfung)} \n$$","pos":19,"type":"cell"}
{"id":0,"time":1700989254366,"type":"user"}
{"last_load":1700955173643,"type":"file"}