{"backend_state":"init","kernel":"python3-ubuntu","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.6"}},"type":"settings"}
{"cell_type":"code","exec_count":11,"id":"3388a7","input":"#Aufgabe 2.2\n\ndef sin_model(t, T, A, b):\n    w = np.pi * 2 / T\n    return A * np.sin(w * t - b)\n\nt_error = 0.0125                                # Uncertainty in time (s)\nx_error = 0.02                                  # Uncertainty in x Axis acceleration (m/s**2)\nfit = kafe2.XYFit(xy_data=[time, x], model_function=sin_model) \nfit.add_error(axis='y', err_val=x_error)\nfit.add_error(axis='x', err_val=t_error)\n\nfit.add_parameter_constraint(name='A',   value=0.8,   uncertainty=0.05)\n\nfit.add_parameter_constraint(name='b',   value=0.25,   uncertainty=0.05)\n\nfit.add_parameter_constraint(name='T',   value=1.6,   uncertainty=d_T)\nfit.limit_parameter(\"T\", lower=1.55, upper=1.65)\n\n\n# Fit ausführen\nfit.do_fit()\nplot = kafe2.Plot(fit)\nplot.y_label = \"$Beschleunigung$\"\nplot.x_label = \"$Zeit$\"\nplot.plot(residual=True)\nplot.show()\nprint(fit)\npar_vals=fit.parameter_values \npar_errs=fit.parameter_errors\nchi = fit.goodness_of_fit / fit.ndf\n\nprint(\"Qualität des Fits über Xi-Quadrat Methode berechnet: \" + str(round(chi, 2)))\nprint(\"Periode: T = \" + str(round(par_vals[0], 5)) + \" +- \" + str(round(par_errs[0], 5)) + \" s\")\nprint(\"Amplitude: A = \" + str(round(par_vals[1], 4)) + \" +- \" + str(round(par_errs[1], 4)) + \" rad/s²\")\nprint(\"Verschiebung: b = \" + str(round(par_vals[2], 3)) + \" +- \" + str(round(par_errs[2], 3)))\n\nT_fit = par_vals[0]\nd_T_fit = par_errs[0]\n\ng_fit = 4 * np.pi**2 * l / (T_fit**2)\n\n\n#Fehler:\n\nd_g_fit = np.sqrt((4 * np.pi**2 / (T_fit**2) * d_l)**2 + (-8 * np.pi**2 * l / (T_fit**3) * d_T_fit)**2)\npull = np.abs(g_fit - g_exp) / np.sqrt(d_g_fit**2 + d_g_exp**2)\nprint(\"Der Pull Beträgt: \" + str(round(pull, 2)))\nprint(\"Gemessene Erdbeschleunigung, über den Fit optimiert: \" + str(round(g_fit, 2)) + \" +- \" + str(round(d_g_fit, 3))+\" m/s²\")\nprint(\"Das Ergebnis ist im Rahmen der Unsicherheit \" + \"nicht \" * (g_exp < g_fit - d_g_fit or g_exp > g_fit + d_g_fit) + \"gut.\")\n","output":{"0":{"data":{"image/png":"797313085d99bc1d0b934d87a555c1a0eb711751","text/plain":"<Figure size 1200x500 with 3 Axes>"},"output_type":"display_data"},"1":{"name":"stdout","output_type":"stream","text":"<kafe2.fit.xy.fit.XYFit object at 0x0000015C0930B460>\nQualität des Fits über Xi-Quadrat Methode berechnet: 1.2\nPeriode: T = 1.59587 +- 0.00041 s\nAmplitude: A = 0.7785 +- 0.0027 rad/s²\nVerschiebung: b = 0.273 +- 0.01\nDer Pull Beträgt: 7.26\nGemessene Erdbeschleunigung, über den Fit optimiert: 9.74 +- 0.009 m/s²\nDas Ergebnis ist im Rahmen der Unsicherheit nicht gut.\n"}},"pos":13,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":12,"id":"c85ac8","input":"#Aufgabe 2.3\n\ndef sin_model(t, g, l, A, b):\n    w = np.sqrt(g / l)\n    return A * np.sin(w * t - b)\n\nt_error = 0.0125                                # Uncertainty in time (s)\nx_error = 0.02                                  # Uncertainty in x Axis acceleration (m/s**2)\nfit = kafe2.XYFit(xy_data=[time, x], model_function=sin_model) \nfit.add_error(axis='y', err_val=x_error)\nfit.add_error(axis='x', err_val=t_error)\n\n\nfit.add_parameter_constraint(name='g',   value=9.8,   uncertainty=0.1)\nfit.limit_parameter(\"g\", lower=9.7, upper=9.9)\n\nfit.add_parameter_constraint(name='l',   value=l,   uncertainty=d_l)\n\nfit.add_parameter_constraint(name='A',   value=0.8,   uncertainty=0.05)\n\nfit.add_parameter_constraint(name='b',   value=0.25,   uncertainty=0.05)\nfit.limit_parameter(\"b\", lower=0.2, upper=0.3)\n\n\n\n\n# Fit ausführen\nfit.do_fit()\nplot = kafe2.Plot(fit)\nplot.y_label = \"$Beschleunigung$\"\nplot.x_label = \"$Zeit$\"\nplot.plot(residual=True)\nplot.show()\nprint(fit)\npar_vals=fit.parameter_values \npar_errs=fit.parameter_errors\nchi =fit.goodness_of_fit / fit.ndf\n\ng_fit = par_vals[0]\nd_g_fit = par_errs[0]\n\npull = np.abs(g_fit - g_exp) / np.sqrt(d_g_fit**2 + d_g_exp**2)\nprint(\"Der Pull Beträgt: \" + str(round(pull, 2)))\nprint(\"Die gemessene Erdbeschleunigung, über den Fit optimiert: \" + str(round(g_fit, 3)) + \" +- \" + str(round(d_g_fit, 4)) + \" m/s²\")\nprint(\"Das Ergebnis ist im Rahmen der Unsicherheit \" + \"nicht \" * (g_exp < g_fit - d_g_fit or g_exp > g_fit + d_g_fit) + \"gut.\")\n\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Warning: the cost function has been evaluated as infinite. The fit might not converge correctly.\n"},"1":{"data":{"image/png":"849afd12ae2280c925b7c7612a5b9ecf6b9e5a58","text/plain":"<Figure size 1200x500 with 3 Axes>"},"output_type":"display_data"},"2":{"name":"stdout","output_type":"stream","text":"<kafe2.fit.xy.fit.XYFit object at 0x0000015C08FED600>\nDer Pull Beträgt: 7.25\nDie gemessene Erdbeschleunigung, über den Fit optimiert: 9.743 +- 0.0092 m/s²\nDas Ergebnis ist im Rahmen der Unsicherheit nicht gut.\n"}},"pos":16,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":14,"id":"1b52c1","input":"#Aufgabe 3.1\ndef sin_model(t, g, A, b):\n    s=0.473\n    theta=0.23523\n    M=0.789\n    w = np.sqrt(g * M * s/theta)\n    return  A * np.sin(w * t - b)\n\nt_error = 0.0125                                # Uncertainty in time (s)\nx_error = 0.02                                  # Uncertainty in x Axis acceleration (m/s**2)\nfit = kafe2.XYFit(xy_data=[time, x], model_function=sin_model) \nfit.add_error(axis='y', err_val=x_error)\nfit.add_error(axis='x', err_val=t_error)\n\nfit.add_parameter_constraint(name='g',   value=9.8,   uncertainty=0.1)\nfit.limit_parameter(\"g\", lower=9.7, upper=9.85)\n\nfit.add_parameter_constraint(name='A',   value=0.8,   uncertainty=0.05)\nfit.limit_parameter(\"A\", lower=0.75, upper=0.85)\n\nfit.add_parameter_constraint(name='b',   value=0.25,   uncertainty=0.05)\nfit.limit_parameter(\"b\", lower=0.2, upper=0.3)\n\n# Fit ausführen\nfit.do_fit()\nplot = kafe2.Plot(fit)\nplot.y_label = \"$Beschleunigung$\"\nplot.x_label = \"$Zeit$\"\nplot.plot(residual=True)\nplot.show()\nprint(fit)\npar_vals=fit.parameter_values \npar_errs=fit.parameter_errors\nchi =fit.goodness_of_fit / fit.ndf\n\ng_fit = par_vals[0]\nd_g_fit = par_errs[0]\nd_g_sys = 0.245\n\npull = np.abs(g_fit - g_exp) / np.sqrt((d_g_fit + d_g_sys)**2 + d_g_exp**2)\nprint(\"Der Pull Beträgt: \" + str(round(pull, 2)))\nprint(\"Gemessene Erdbeschleunigung, über den Fit optimiert, unter der Berücksichtigung des Trägheitsmoments: \" + str(round(g_fit, 2)) + \" +- \" + str(round(d_g_fit + d_g_sys, 3)) + \"m/s²\")\n\n","output":{"0":{"data":{"image/png":"3ea3c519adc2f58908b775daf2a20346bca08f25","text/plain":"<Figure size 1200x500 with 3 Axes>"},"output_type":"display_data"},"1":{"name":"stdout","output_type":"stream","text":"<kafe2.fit.xy.fit.XYFit object at 0x0000015C09703640>\nDer Pull Beträgt: 0.16\nGemessene Erdbeschleunigung, über den Fit optimiert, unter der Berücksichtigung des Trägheitsmoments: 9.77 +- 0.25m/s²\n"}},"pos":20,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":23,"id":"b3a8e4","input":"#Aufgabe 3.2\n\ndef sin_exp_model(t, g, A, b, tau):\n    s=0.473\n    theta=0.23523\n    M=0.789\n    w = np.sqrt(g * M * s / theta - 1 / tau**2)\n    return A * np.exp(-t/tau) * np.sin(w * t - b) \n\nt_error = 0.0125                                # Uncertainty in time (s)\nx_error = 0.02                                  # Uncertainty in x Axis acceleration (m/s**2)\nfit = kafe2.XYFit(xy_data=[time, x], model_function=sin_exp_model) # x-Werte hier die Massen\nfit.add_error(axis='y', err_val=x_error)\nfit.add_error(axis='x', err_val=t_error)\n\nfit.add_parameter_constraint(name='g',   value=9.8,   uncertainty=0.1)\nfit.limit_parameter(\"g\", lower=9.75, upper=9.85)\n\nfit.add_parameter_constraint(name='A',   value=0.8,   uncertainty=0.05)\n\nfit.add_parameter_constraint(name='b',   value=0.25,   uncertainty=0.05)\n\nfit.add_parameter_constraint(name='tau',   value=245,   uncertainty=20)\n\n\n# Fit ausführen\nfit.do_fit()\nplot = kafe2.Plot(fit)\nplot.y_label = \"$Beschleunigung$\"\nplot.x_label = \"$Zeit$\"\nplot.plot(residual=True)\nplot.show()\nprint(fit)\npar_vals=fit.parameter_values \npar_errs=fit.parameter_errors\nchi =fit.goodness_of_fit / fit.ndf\n\ng_fit = par_vals[0]\nd_g_fit = par_errs[0]\n\npull = np.abs(g_fit - g_exp) / np.sqrt((d_g_fit + d_g_sys)**2 + d_g_exp**2)\nprint(\"Der Pull Beträgt: \" + str(round(pull, 2)))\nprint(\"Gemessene Erdbeschleunigung, über den Fit optimiert: \" + str(round(g_fit, 3)) + \" +- \" + str(round(d_g_fit + d_g_sys, 4)) + \"m/s²\")","output":{"0":{"data":{"image/png":"86f226163bba462ea368437822bfb63b5684f73f","text/plain":"<Figure size 1200x500 with 3 Axes>"},"output_type":"display_data"},"1":{"name":"stdout","output_type":"stream","text":"<kafe2.fit.xy.fit.XYFit object at 0x0000015C096EA590>\nDer Pull Beträgt: 0.15\nGemessene Erdbeschleunigung, über den Fit optimiert: 9.771 +- 0.25m/s²\n"}},"pos":24,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"5494c7","input":"import warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np\nimport kafe2\nimport PhyPraKit as ppk\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport os\nmpl.rcParams['figure.dpi']=200","pos":4,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"075c98","input":"raw_data = np.genfromtxt( \"data_raw.csv\", \n                      delimiter=\",\", \n                      skip_header=1 ) # Einlesen der Daten, speichern in Variablen\ntime_raw = raw_data[:,0]\nx_raw = raw_data[:,1]\ny_raw = raw_data[:,2]\nz_raw = raw_data[:,3]\nacc_raw = raw_data[:,4]\n\nsampled_data = np.genfromtxt(\"data_down_sampled.csv\", delimiter=\",\", skip_header=1)\n\ntime_sam = sampled_data[:,0]\nx_sam = sampled_data[:,1]\ny_sam = sampled_data[:,2]\nz_sam = sampled_data[:,3]\nacc_sam = sampled_data[:,4]\n\nprint(\"Größe von 'data_raw.csv' in MB: \" + str(round(os.path.getsize(\"./data_raw.csv\")/1024**2, 2))) # berechne die Größe der Dateien\nprint(\"Größe von 'data_down_sampled.csv' in MB: \" + str(round(os.path.getsize(\"./data_down_sampled.csv\")/1024**2, 2)))\n\nupper_lim = 12000 #len(time_raw - 1)\nf, (ax1, ax2, ax3, ag) = plt.subplots(4, 1, sharex = True, sharey = True)\n\nax1.plot((time_raw[:upper_lim])-time_raw[0], x_raw[:upper_lim], label = \"raw x\")\nax1.legend(loc=\"upper right\")\nax2.plot((time_raw[:upper_lim])-time_raw[0], y_raw[:upper_lim], label = \"raw y\")\nax2.legend()\nax3.plot((time_raw[:upper_lim])-time_raw[0], z_raw[:upper_lim], label = \"raw z\")\nax3.legend()\nag.plot((time_raw[:upper_lim])-time_raw[0], acc_raw[:upper_lim], label = \"absolute acceleration\")\nag.legend()\nplt.xlabel(\"Zeit in s\")\nplt.ylabel(\"Beschleunigung in m/s^2\")\nplt.show()\n\nf, (ax1, ax2, ax3, ag) = plt.subplots(4, 1, sharex = True, sharey = True)\nax1.plot(time_sam-time_sam[0], x_sam, label = \"sampled x\")\nax1.legend(loc=\"upper right\")\nax2.plot(time_sam-time_sam[0], y_sam, label = \"sampled y\")\nax2.legend()\nax3.plot(time_sam-time_sam[0], z_sam, label = \"sampled z\")\nax3.legend()\nag.plot(time_sam-time_sam[0], acc_sam, label = \"sampled absolute acceleration\")\nag.legend()\n\n\nplt.xlabel(\"Zeit in s\")\nplt.ylabel(\"Beschleunigung in m/s^2\")\ntime = time_sam - time_sam[0]\nx = x_sam\ny = y_sam\nz = z_sam","output":{"0":{"name":"stdout","output_type":"stream","text":"Größe von 'data_raw.csv' in MB: 2.31\nGröße von 'data_down_sampled.csv' in MB: 0.01\n"},"1":{"data":{"image/png":"70f6f5592b970c2bd538e1025d80ffdafb2436fe","text/plain":"<Figure size 1280x960 with 4 Axes>"},"output_type":"display_data"},"2":{"data":{"image/png":"2c76758aa6e867560464453c4b501c41760d7099","text/plain":"<Figure size 1280x960 with 4 Axes>"},"output_type":"display_data"}},"pos":6,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":5,"id":"6521f9","input":"#Aufgabe 2.1\nimport scipy # für peak finder\nwi = 3\npos_peaks, _ = scipy.signal.find_peaks(x_sam, width = wi) # suche nach beschleunigungspeaks in x - Richtung\nplt.plot(time, x, label = \"x - Beschleunigung\")\nplt.plot(time[pos_peaks], x[pos_peaks], \"x\", label = \"Maxima\")\nplt.legend(loc = \"lower right\")\nplt.xlabel(\"Zeit in Sekunden\")\nplt.ylabel(\"Beschleunigung in m/s^2\")\nplt.title(\"Gefilterte Daten\")\nT = (time[pos_peaks[1]] - time[pos_peaks[0]] )\nl = 0.6285\n# abgeschätzte/abgelesene (absolute) Unsicherheit: \nt_error = 0.0125                                # Uncertainty in time (s)\nx_error = 0.02                                  # Uncertainty in x Axis acceleration (m/s**2)\n\nd_T = np.sqrt(2) * t_error\nd_l = 0.0005\n\ng = 4 * np.pi**2 * l / (T**2)\ng_exp = 9.8095099\nd_g_exp = 0.000034\n\n#Fehler:\n\nd_g = np.sqrt((4 * np.pi**2 / (T**2) * d_l)**2 + (-8 * np.pi**2 * l / (T**3) * d_T)**2) # Fehler auf g nach obiger Formel\n\nprint(\"Gemessene Erdbeschleunigung: \" + str(round(g, 0)) + \" +- \" + str(round(d_g, 2)) + \"m/s²\")\nprint(\"Das Ergebnis ist im Rahmen der Unsicherheit \" + \"nicht \" * (g_exp < g - d_g or g_exp > g + d_g) + \"gut.\")","output":{"0":{"name":"stdout","output_type":"stream","text":"Gemessene Erdbeschleunigung: 11.0 +- 0.26m/s²\nDas Ergebnis ist im Rahmen der Unsicherheit nicht gut.\n"},"1":{"data":{"image/png":"c4b50ecf7784fae71f41b32bb87e28712a107a7f","text/plain":"<Figure size 1280x960 with 1 Axes>"},"output_type":"display_data"}},"pos":10,"state":"done","type":"cell"}
{"cell_type":"code","id":"f1aad5","input":"","pos":27,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"05ab52","input":"## Aufgabe 3: Schrittweise Erweiterung des Modells\n\n**Hinweise zu allen hier durchzuführenden Messungen finden Sie in der Datei [Hinweise-Aufgabe-3.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/tree/main/Vorversuch/doc/Hinweise-Aufgabe-3.md).**\n\nEine offensichtliche Unzulänglichkeit des vorherigen Modells besteht in der Vernachlässigung der endlichen Ausdehnung des Pendels. Wenn Sie das Modell entsprechend erweitern, nimmt die Formel zur Bestimmung von $g$ die folgende Form an: \n\n$$\n\\begin{equation*}\ng = \\frac{4\\,\\pi^{2}}{T^{2}}\\frac{\\Theta}{Ms},\n\\end{equation*}\n$$\n\nwobei $\\Theta$ und $M$ dem Trägheitsmoment und der Masse der gesamten Pendelkonstruktion (einschließlich aller Montageteile und Smartphone!) und $s$ dem Abstand zwischen dem Schwerpunkt und der Aufhängung des Pendels entsprechen.\n\n### Aufgabe 3.1: Erste Erweiterung des Modells \n\n * Modifizieren Sie Ihr Modell, so dass es dem Modell eines [physikalischen Pendels](https://de.wikipedia.org/wiki/Physikalisches_Pendel) entspricht und machen Sie eine neue Abschätzung für $g^{(3.1)}$ und $\\Delta g^{(3.1)}$. \n * Schätzen Sie den Einfluss von $\\Delta\\Theta$, $\\Delta M$, und $\\Delta s$ auf $\\Delta g^{(3.1)}$ ab und überlegen Sie, wie Sie diese Unsicherheiten geeignet zu einer Gesamtunsicherheit kombinieren können.\n\n### Aufgabe 3.2: Zweite Erweiterung der Modells\n\nDas Pendel erfährt in seiner Bewegung zusätzlich eine Dämpfung. Wenn Sie der Messung das Modell einer [linearer gedämpften Schwingung](https://de.wikipedia.org/wiki/Schwingung#Linear_ged%C3%A4mpfte_Schwingung) zugrunde legen verändert sich die Formel zur Bestimmung von $g$ wie folgt: \n\n$$\n\\begin{equation}\ng = \\left(\\frac{4\\,\\pi^{2}}{T_{0}^{2}}+\\frac{1}{\\tau^{2}}\\right)\\frac{\\Theta}{m\\,\\ell},\n\\end{equation}\n$$\n\nwobei $\\tau$ einer Abklingzeit der Schwingungsamplitude in Sekunden entspricht. Wie Sie sehen handelt es sich um eine Korrektur, die die Abschätzung von $g$ zu größeren Werten hin verändert. \n\nVerändern Sie ihr Modell geeignet und beantworten Sie die folgenden Fragen: \n  * Kann das zugrundeliegende Modell die Daten beschreiben? \n  * Wie könnten Sie die Hypothese, dass das zugrundeliegende Modell die Daten beschreiben kann, noch besser testen? \n  * Wie groß ist der Effekt der Korrektur aus der obigen Gleichung auf die Messung von $g$? \n\n---","pos":18,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0faf50","input":"Der Einfluss auf $\\Delta g$ von $\\Delta\\Theta, \\Delta s, \\Delta M$ ist wie folgt:\n$$\\Delta\\Theta \\rightarrow \\Delta g = 0.15 m/s²$$\n$$\\Delta s \\rightarrow \\Delta g = 0.15 m/s²$$\n$$\\Delta M\\rightarrow \\Delta g = 0.1235 m/s²$$\nDiese Werte ergeben sich, indem die obere und untere Grenze von $\\Theta,  s, M$ aus dem Datenblatt jeweils in das Modell anstelle des tatsächlichen Wertes eingegeben werden. $\\Delta g$ ist dann die Differenz von g zwischen dem oberen eingegebenen Wert von $\\Theta,  s, M$  und dem Unteren.\nSie können mit dem arithmetischen Mittel geeignet kombiniert werden: \n$$\\Delta g_{sys} = \\sqrt{\\Delta\\Theta^2 + \\Delta s^2 + \\Delta M^2} = 0.245 \\frac{m}{s^2}$$\nDaraus ergibt sich der systematische Fehler, da die Werte und Unsicherheiten keine Parameter des Fits sind. Dieser wurde bei der Berechnung des Pulls bereits berücksichtigt. Bei dem tatsächlichen Fehler auf g muss der systematische Fehler noch auf den Fehler, den der Fit liefert, addiert werden.","pos":22,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1af5ee","input":"Obwohl das Ergebnis immer noch nicht gut ist, ist der ermittelte Wert bereits sehr viel besser, als in Aufgabe 2.1. Dennoch kann das Modell und die Methode weiter verbessert werden, weil einige Tatscachen noch unberücksichtig bleiben.","pos":14,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2a9028","input":"### Aufgabe 2.3\nDie Qualität des Fits ist für die einfach Funktion, die verwendet wurde, akzeptabel. Bei der $\\chi^2$ Methode gilt, dass der Fit besser wird, desto näher $\\frac{\\chi^2}{ndf}$ an 1 ist. Dass eine gewisse Periodizität im Residual zu erkennen ist lässt aber darauf schließen, dass es ein Modell gibt, welche die Daten aber noch besser beschreibt. Interessanterweise ist der Resiudal Graph fast übber all größer als null. Dies hängt wohl damit zusammen, dass die negativen Auslenkungen in den Daten eine kleinere Amplitude als die positiven Daten haben.","pos":15,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"356b3b","input":"### Aufgabe 1\nZur Bestimmung der Größe der Datei wird die Funktion $path.getsize$ im $os$ Modul verwendet.\nBei den Rohdaten werden nur die ersten 12000 Datenpunkte geplottet, um eine gewisse Übersich zu behalten.","pos":5,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"377d79","input":"### Aufgabe 3.1\nIn dieser Aufgabe soll das Modell verbessert werden. Dazu wird die bisher vernachlässigte Auslenkung des Stabes, an dem das Handy schwingt berücksichtigt. Es wird also das Trägheitsmoment $\\Theta$ des Stabes berücksichtigt. Das neue Modell ist $ \\ddot{\\Phi}(t) = A sin(\\omega t - b) $ mit $ \\omega = \\sqrt{\\frac{g M s}{\\Theta}}$. In diesem Modell wird also auch das Trägheitsmoment des Stabes beachtet.","pos":19,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"3b0f08","input":"## Aufgabe 2: Mathematische Pendel\n\n**Hinweise zu allen hier durchzuführenden Messungen finden Sie in der Datei [Hinweise-Aufgabe-2.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/tree/main/Vorversuch/doc/Hinweise-Aufgabe-2.md).**\n\nZur Bestimmung von $g$ unterlegen wir zunächst das Modell eines [mathematischen Pendels](https://de.wikipedia.org/wiki/Mathematisches_Pendel), woraus sich $g$ wie folgt ableiten lässt:\n\n$$\n\\begin{equation*}\ng = \\frac{4\\,\\pi^{2}}{T^{2}}\\ell,\n\\end{equation*}\n$$\n\nwobei $\\ell$ der Länge des Pendels entspricht. Als Referenzwert für alle weiteren Messungen können Sie den Wert \n\n$$\n\\begin{equation*}\ng_{\\mathrm{exp}} = (9.809599\\pm0.000034)\\,\\mathrm{m/s^{2}}\n\\end{equation*}\n$$\n\nverwenden. Dieser Wert wurde aus der [Global Gravtiy Database des Bureau Gravimetrique International (BGI)](https://ggos.org/item/bgi/) für die Stadt Mannheim (bei $49,49^{\\circ}$ nördlicher Breite und $8,53^{\\circ}$ westlicher Länge auf einer Referenzhöhe von $101\\,\\mathrm{m}$) ausgelesen. \n\n### Aufgabe 2.1: Referenzmessung von $T$ \n\n * Bestimmen Sie **einen einzelnen Wert** für die Periode $T$ in den Daten. \n * Überlegen Sie sich eine sinnvolle Unsicherheit $\\Delta T$ und ermitteln Sie $g$ mit entsprechender Unsicherheit $\\Delta g^{(2.1)}$. Bestimmen Sie $\\Delta g^{(2.1)}$ mit Hilfe linearer [Fehlerfortpflanzung](https://de.wikipedia.org/wiki/Fehlerfortpflanzung) nach Gauß. Berücksichtigen Sie dabei auch die Unsicherheit $\\Delta\\ell$.\n * Vergleichen Sie Ihr Ergebnis, im Rahmen der Unsicherheiten, mit $g_{\\mathrm{exp}}$.\n\n### Aufgabe 2.2: Erste Verbesserung der Methodik \n\n * Bestimmen Sie $T$ aus einer Anpassung an alle Datenpunkte, bestehend aus den Wertepaaren $\\left(t,\\varphi(t)\\right)$. Berücksichtigen Sie dabei die Unsicherheiten sowohl auf $t$, als auch auf $\\varphi(t)$. Angaben zu diesen Unsicherheiten können Sie z.B. der Datei [Datenblatt.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/blob/main/Vorversuch/Datenblatt.md) entnehmen. Stellen Sie die Daten und das angepasste Modell geeignet graphisch dar. \n * Notieren Sie die folgenden wichtigen Ausgaben der Anpassung: \n    * Qualität der Anpassung (quantifiziert durch die Größe $\\hat{\\chi}^{2}/n_{\\mathrm{dof}}$) \n    * Die ermittelten Werte mit entsprechenden Unsicherheiten für alle an die Daten angepassten Parameter. \n * Berechnen Sie aus den bestimmten Werten für $T$ und $\\Delta T$ verbesserte Abschätzungen für $g^{(2.2)}$ und $\\Delta g^{(2.2)}$. Bestimmen Sie $\\Delta g^{(2.2)}$ mit Hilfe linearer [Fehlerfortpflanzung](https://de.wikipedia.org/wiki/Fehlerfortpflanzung) nach Gauß. Berücksichtigen Sie dabei auch die Unsicherheit $\\Delta\\ell$.\n * Vergleichen Sie Ihr Ergebnis, im Rahmen der Unsicherheiten, mit $g_{\\mathrm{exp}}$. \n \n### Aufgabe 2.3: Zweite Verbesserung der Methodik\n\n * Bestimmen Sie $g^{(2.3)}$ und $\\Delta g^{2.3}$ direkt aus der Anpassung. Formulieren Sie ihre Modellfunktion dazu entsprechend um, führen Sie die Anpassung erneut durch und vergleichen Sie die Ergebnisse für $g^{(2.3)}$ und $\\Delta g^{(2.3)}$ mit den Ergebnissen aus Aufgabe 2.2. \n * Überlegen Sie, wie Sie in diesem Fall $\\Delta\\ell$ im Ergebnis von $\\Delta g^{(2.3)}$ berücksichtigen können.\n\n---","pos":8,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"447be6","input":"### Aufgabe 3.2\nNun soll neben dem Trägheitsmoment des Stabes auch die Reibung berücksichtigt werden. Diese wird im neunen Modell durch eine zeitabhängige Amplitude berücksichtig. konkret bedeutet dies, dass die Amplitude mit dem Faktor $ e^{-\\frac{t}{\\tau}}$ multipliziert wird. Hierbei ist $\\tau$ eine größe für die Reibung. Desto kleiner $\\tau$, desto schneller sinkt die Amplitude. Das neue Modell ist $ \\ddot{\\Phi}(t) = A e^{-\\frac{t}{\\tau}} sin(\\omega t - b) $ mit $ \\omega = \\sqrt{\\frac{gMs}{\\Theta} - \\frac{1}{\\tau}^2}$","pos":23,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4785b5","input":"### Aufgabe 2.1\nDie  Unsicherheit auf $T$ lässt sich mit dem Fehlerfortpflanzungsgesetz durch \n\n$$ T = t_{max 2} - t_{max 1} $$\n\n$$\\Rightarrow \\Delta T = \\sqrt 2  \\Delta t $$\n\nbeschreiben. $\\Delta t = 0.0125 s$ ist die gegebene Unsicherheit der Messung in x-Richtung (Also die Unsicherheit der Zeitmessung). Um einen Wert für die Periode zu finden, wird die Funktion $signal.find\\_peaks$ aus dem $scipy$ Modul verwendet. Die Periodendauer ergibt sich dann aus der Differenz von zwei benachbarten Peaks. Hier wurde der erste und der zweite Peak verwendet ($t_{max 1}$ bzw. $t_{max 2}$). \n\n\nDie Unsicherheit auf g lässt sich mit dem Fehlerfortpflanzungsgesetz zu\n\n$$ \\Delta g = \\sqrt{\\Bigl(\\frac{4 \\pi^2}{T^2} \\Delta l \\Bigr)^2 + \\Bigl(\\frac{ - 8 \\pi^2 l}{T^3} \\Delta T \\Bigr)^2} $$\n\nberechnen. ","pos":9,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4b5331","input":"Es ist eine Verbesserng des Fits festzustellen. Der Pull in Aufgabe 2.2 beträgt 7.25, hier nur 0.16. Auch der $\\frac{\\chi ^2}{ndf} $ Test lässt auf eine leichte Verbesserung des Modells schlißen. Im Residual ist jedoch immer noch eine Periodizität zu erkennen, das Modell kann also immer noch verbessert werden.","pos":21,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"67efb0","input":"Es ist zu erkennen, dass in x-Richtung eine periodische Schwingung stattfindet, welche mit der Zeit abklingt. In der y- und z- Richtung ist die Amplitude der Beschleunigung sehr viel kleiner und nicht so periodisch, im Vergleich zur x-Richtung. Für die folgende Analyse werden die Daten aus der x-Richtung verwendet.","pos":7,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"6b617c","input":"Name: Achtner Vorname: Martin E-Mail: ms.achtner@googlemail.com / urrvl@student.kit.edu\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nName: __________________ Vorname: __________________ E-Mail: __________________\nasdfagadg\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nGruppennummer: Mo01\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\n\nBetreuer: __________________\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n\\end{equation*}\n\nVersuch durchgeführt am: 30.10.2003","pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"83418a","input":"Es ist nicht klar, wieso ndf in Versuch drei den Wert 171 hat.","pos":26,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8dbdb7","input":"### Aufgabe 2.2 \nUm den Fit durchführen zu können wird ein Modell benötigt. Dieses ist zuerst eine einfache Sinus Funktion.\nAls Modell wird eine Sinusfunktion der Form $\\ddot{\\Phi}(t) = A sin(\\omega t - b) $ mit $ \\omega = \\frac{2 \\pi}{T} $verewendet. Für den Fit werden folgende Anfangswerte verwendet: \n$$ A = 0.8 \\frac{rad}{s^2} \\quad \\Delta A = 0.05 \\frac{rad}{s^2}$$\n$$ b = 0.25 \\quad \\Delta b = 0.05$$\n$$ T = 1.6 s \\quad \\Delta T = 0.26 s$$\n(A und b durch abschätzen, T durch Aufgabenteil 2.1).\nDer Fit wird mit der kafe2 Bibliothek durchgeführt.\nZur Auswertung wird zusärtzlich zu $\\frac{\\chi^2}{ndf}$ die Größe $Pull = \\frac{|g_{exp} - g_{fit}|}{\\sqrt{\\Delta g_{exp}^2 + \\Delta g_{fit}^2}}$ verwendet. Desto kleiner sie ist, desto besser ist der Messwert im Rahmen der Unsicherheit.","pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"99ca1c","input":"Das Modell kann die Daten gut beschreiben, da sowohl der Pull sich noch etwas verbessert hat, aber auch die $\\frac{\\chi^2}{ndf}$ Wahrscheinlichkeit mit 42.7% einen Wert annimmt, welche zur Annahme der Hypothese, dass dieses Modell die Daten beschreibt ausreichen würde. Auch die bisherige Periodizität im Resiudal ist verschwunden. Interessant ist, dass der Residual nun keine erkennbare Periodizität hat, aber überalls größer als null ist.","pos":25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c77a80","input":"---\n\n**Beanstandungen:**\n\n\\begin{equation*}\n\\begin{split}\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n&\\\\\n\\end{split}\n%\\text{\\vspace{10cm}}\n\\end{equation*}\n\n<br>\nTestiert am: __________________ Testat: __________________","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d6a66e","input":"# Fakultät für Physik\n\n## Physikalisches Praktikum P1 für Studierende der Physik\n\nPraktikumsvorversuch\n\n\n\n\n\n# Datenverarbeitung am Beispiel des Pendels","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e18d23","input":"Es ist nicht sehr überraschend, dass mit dieser Methode nur eine sehr grobe Abschätzung von g möglich ist, die weit von dem tatsächlichen Wert entfernt ist. Es ist auch erwähnenswert, dass eine andere Wahl der Maximas, oder eine andere Methode, um die Maximas zu bestimmen, andere Ergebnisse liefern wird. Auch die Betrachtung der Minimas, oder Nullstellen der Funktion wird ein anderes Ergebnis liefern. Um dies einzusehen, muss man lediglich den Graph betrachten und erkennen, dass es so aussieht, wie wenn dieser leicht in die positive y-Richtung verschoben worden wäre.","pos":11,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f46820","input":"# Durchführung\n\n## Aufgabe 1: Umgang mit großen Datensätzen\n\n**Hinweise zu allen hier durchzuführenden Messungen finden Sie in der Datei [Hinweise-Aufgabe-1.md](https://gitlab.kit.edu/kit/etp-lehre/p1-praktikum/students/-/tree/main/Vorversuch/doc/Hinweise-Aufgabe-1.md).**\n\n * Öffnen Sie die Dateien ```data_raw.csv``` und ```data_down_sampled.csv``` per Doppelklick und untersuchen die Spalten und Zeilen. \n * Geben Sie die Größe der Dateien in MB an. \n * Stellen Sie die einzelnen Spalten jeweils in einem Diagramm, als Funktion der Zeit $t$ dar.\n \n Verwenden Sie für alle weiteren Untersuchung die Datei ```data_down_sampled.csv```. \n\n---","pos":3,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f9239c","input":"Die Unsicherheit von $l$ wurde dem Modell mit der Funktion \"add_parameter_constraint\" hinzugefügt. Normalerweise ist diese Funktion lediglich dafür da, Werte hinzuzufügen, die durch den Fit bestimmt werden sollen. $l$ ist nicht solch ein Wert, da dieser Wert gemessen wurde, er also in keiner Weise irgendwie optimiert werden muss. Da sich hier aber nicht sehr viel am Wert von $l$, oder $\\Delta l$ ändert, liefert dies Richtige Ergebnisse. Alternativ wäre es ebenfalls möglich, einen festen Wert von $l$ anzugeben, und dann den endgültigen Fehler von $g$ durch das arithmetische Mittel zwischen $\\Delta l$ und dem Fehler auf g, den der Fit liefert, zu berechnen. In Aufgabe drei wird dies auch so gemacht, da es ansonsten zu viele Parameter gäbe, die gefittet werden müssten. Die Qualität des Fits ändert sich nicht wirklich, da lediglich die Mehtode verbessert wurde, nicht aber das Modell.","pos":17,"state":"done","type":"cell"}
{"id":0,"time":1700229480933,"type":"user"}
{"last_load":1699952343617,"type":"file"}